მატრიცების გამრავლება (ნაკადები) - 50 ქულა
დაწერეთ parallelMatrixMultiply მეთოდი რომელსაც გადაეცემა 2 მატრიცი (A[][] - m x n და B[][] -  n x p) და აბრუნებს მატრიცების ნამრავლს (m x p განზომილების).

ამოცანა უნდა გადაიჭრას m * n * p რაოდენობის ნაკადით(მაქსიმალური პარალელიზაციით, იტერაციული ამოხსნა არ ჩაითვლება), სადაც თითოეული ნაკადი ითვლის რა რიცხვი უნდა დაემატოს საშედეგო C მატრიცის კონკრეტულ უჯრაზე. მაგალითად A[0][0] და B[0][0] ის ნამრავლი ემატება C[0][0]-ზე, თუმცა C[0][0]-ზე ასევე დაემატება A[0][1] * B[1][0] რომელიც სხვა ნაკადმა უნდა შეასრულოს.

გამრავლების ალგორითმი:
მატრიცის ელემენტი C[i][j] ითვლება ასე:
C[i][j] = A[i][0] * B[0][j] + A[i][1] * B[1][j] + ... + A[i][n-1] * B[n-1][j]

ანუ, პირველი მატრიცის სტრიქონებს ვამრავლებთ მეორე მატრიცის სვეტებზე და შედეგებს ვკრეფთ C მატრიცის შესაბამის უჯრაში.


მაგალითად:
A = [ [1, 2, 3],
      [4, 5, 6] ]

B = [ [7, 8],
      [9, 10],
      [11, 12] ]

C = [ [58, 64],
      [139, 154] ]

C[0][0] = 1×7 + 2×9 + 3×11 = 58
C[0][1] = 1×8 + 2×10 + 3×12 = 64
C[1][0] = 4×7 + 5×9 + 6×11 = 139
C[1][1] = 4×8 + 5×10 + 6×12 = 154

ამ მაგალითისთვის გვექნება 12 ნაკადი. თითოეული შესაბამის უჯრაზე დაამატებს თითო ნამრავლს.

ქვემოთ მოცემული კოდი სწორად ითვლის მატრიცების ნამრავლს, მაგრამ მუშაობს მხოლოდ ერთი ნაკადით, ამიტომ არ აკმაყოფილებს ამოცანის მოთხოვნებს:

for (int i = 0; i < m; i++) {
    for (int j = 0; j < p; j++) {
        for (int k = 0; k < n; k++) {
            C[i][j] += A[i][k] * B[k][j];
        }
    }
}
